// Code generated by neuron/generator. DO NOT EDIT.
// This file was generated at:
// Wed, 13 May 2020 22:38:59 +0200

package tests

import (
	"context"

	"github.com/neuronlabs/neuron/controller"
	"github.com/neuronlabs/neuron/errors"
	"github.com/neuronlabs/neuron/mapping"
	"github.com/neuronlabs/neuron/query"
)

func init() {

	_collectionInitializers = append(_collectionInitializers, initializeUsers)
	_collectionInitializers = append(_collectionInitializers, initializeCars)
}

type _collectionInitializer func() error

var _collectionInitializers []_collectionInitializer

// Neuron_InitializeCollections collections for provided controller.
func Neuron_InitializeCollections() (err error) {
	for _, initializer := range _collectionInitializers {
		if err = initializer(); err != nil {
			return err
		}
	}
	return nil
}

// Users is the collection used to query User model.
var Users *users

type users struct {
	Model *mapping.ModelStruct
}

func initializeUsers() error {
	mStruct, err := controller.ModelStruct(&User{})
	if err != nil {
		return err
	}
	Users = &users{Model: mStruct}
	return nil
}

// Query creates the query for the User.
func (u *users) Query(db query.DB, models ...*User) *usersQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(u.Model, queryModels...)
	return &usersQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the User with provided 'ctx' context.
func (u *users) QueryCtx(ctx context.Context, db query.DB, models ...*User) *usersQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, u.Model, queryModels...)
	return &usersQueryBuilder{builder: builder}
}

// usersQueryBuilder is the query builder used to create and execute
// queries for the Usermodel.
type usersQueryBuilder struct {
	builder query.Builder
	err     error
}

// Scope returns given query scope.
func (u *usersQueryBuilder) Scope() *query.Scope {
	return u.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (u *usersQueryBuilder) Err() error {
	if u.err != nil {
		return u.err
	}
	return u.builder.Err()
}

// Ctx returns the context of given query builder.
func (u *usersQueryBuilder) Ctx() context.Context {
	return u.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (u *usersQueryBuilder) Count() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Count()
}

// Insert new 'User' instance(s) into the store.
func (u *usersQueryBuilder) Insert() error {
	if u.err != nil {
		return u.err
	}
	return u.builder.Insert()
}

// Update updates given 'User' instances.
func (u *usersQueryBuilder) Update() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Update()
}

// Find returns all User models that matches to given query.
func (u *usersQueryBuilder) Find() ([]*User, error) {
	if u.err != nil {
		return nil, u.err
	}
	queryModels, err := u.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*User, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*User)
	}
	return models, nil
}

// Get returns single User model that matches given query.
// If the model is not found the function returns error of class.QueryValueNoResult.
func (u *usersQueryBuilder) Get() (*User, error) {
	if u.err != nil {
		return nil, u.err
	}
	model, err := u.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*User), nil
}

// Delete deletes all User values from the store that matches given query.
func (u *usersQueryBuilder) Delete() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	return u.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (u *usersQueryBuilder) Filter(filter *query.FilterField) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Filter(filter)
	return u
}

// Where creates query with given 'filter' and 'values'.
func (u *usersQueryBuilder) Where(filter string, values ...interface{}) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Where(filter, values...)
	return u
}

// IncludeFavoriteCar includes given 'relation' in the users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeFavoriteCar(favoriteCarFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := Users.Model.RelationByIndex(10)
	if err != nil {
		u.err = errors.Newf(mapping.ClassInternal, "Getting 'FavoriteCar' by index for model 'User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range favoriteCarFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not found for the 'Car' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeCars includes given 'relation' in the users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeCars(carsFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := Users.Model.RelationByIndex(11)
	if err != nil {
		u.err = errors.Newf(mapping.ClassInternal, "Getting 'Cars' by index for model 'User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range carsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not found for the 'Car' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeSons includes given 'relation' in the users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeSons(sonsFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := Users.Model.RelationByIndex(12)
	if err != nil {
		u.err = errors.Newf(mapping.ClassInternal, "Getting 'Sons' by index for model 'User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range sonsFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not found for the 'User' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// IncludeSister includes given 'relation' in the users query.
// An optional 'relationFieldset' defines the fields to return in the included relation.
func (u *usersQueryBuilder) IncludeSister(sisterFieldset ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	relation, err := Users.Model.RelationByIndex(13)
	if err != nil {
		u.err = errors.Newf(mapping.ClassInternal, "Getting 'Sister' by index for model 'User' failed: %v", err)
		return u
	}
	// check the fieldset for the relation.
	var relationFields []*mapping.StructField
	for _, field := range sisterFieldset {
		structField, ok := relation.ModelStruct().FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not found for the 'User' model", field)
			return u
		}
		relationFields = append(relationFields, structField)
	}
	u.builder.Include(relation, relationFields...)
	return u
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (u *usersQueryBuilder) Limit(limit int64) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Limit(limit)
	return u
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (u *usersQueryBuilder) Offset(offset int64) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	u.builder.Offset(offset)
	return u
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - CreatedAt / created_at
//  - DeletedAt / deleted_at
//  - Name / name
//  - Age / age
//  - Bytes / bytes
//  - PtrBytes / ptr_bytes
//  - Wrapped / wrapped
//  - PtrWrapped / ptr_wrapped
//  - External / external
func (u *usersQueryBuilder) Select(fields ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := Users.Model.FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not valid for model: 'users'", field)
			return u
		}
		fieldSet = append(fieldSet, structField)
	}
	u.builder.Select(fieldSet...)
	return u
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - CreatedAt
//  - DeletedAt
//  - Name
//  - Age
//  - Bytes
//  - PtrBytes
//  - Wrapped
//  - PtrWrapped
//  - External
func (u *usersQueryBuilder) OrderBy(fields ...string) *usersQueryBuilder {
	if u.err != nil {
		return u
	}
	var sortFields []*query.SortField
	for _, field := range fields {
		if len(field) == 0 {
			u.err = errors.New(mapping.ClassInvalidModelField, "cannot set sorting order for an empty field for model: 'users'")
			return u
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := Users.Model.FieldByName(field)
		if !ok {
			u.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not valid for model: 'users'", field)
			return u
		}
		sortFields = append(sortFields, &query.SortField{StructField: structField, Order: order})
	}
	u.builder.OrderBy(sortFields...)
	return u
}

// AddFavoriteCar adds related model FavoriteCar and matches to given User.
func (u *usersQueryBuilder) AddFavoriteCar(favoriteCar *Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(10)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'FavoriteCar' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.AddRelations(relation, favoriteCar)
}

// AddCars adds related model Cars and matches to given User.
func (u *usersQueryBuilder) AddCars(cars ...*Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(11)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Cars' relation by index for model 'User' failed: %v", err)
	}
	models := make([]mapping.Model, len(cars))
	for i := range cars {
		models[i] = cars[i]
	}
	return u.builder.AddRelations(relation, models...)
}

// AddSons adds related model Sons and matches to given User.
func (u *usersQueryBuilder) AddSons(sons ...*User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(12)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Sons' relation by index for model 'User' failed: %v", err)
	}
	models := make([]mapping.Model, len(sons))
	for i := range sons {
		models[i] = sons[i]
	}
	return u.builder.AddRelations(relation, models...)
}

// AddSister adds related model Sister and matches to given User.
func (u *usersQueryBuilder) AddSister(sister *User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(13)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Sister' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.AddRelations(relation, sister)
}

// SetFavoriteCar sets related model FavoriteCar and matches to given User.
func (u *usersQueryBuilder) SetFavoriteCar(favoriteCar *Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(10)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'FavoriteCar' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.SetRelations(relation, favoriteCar)
}

// SetCars sets related model Cars and matches to given User.
func (u *usersQueryBuilder) SetCars(cars ...*Car) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(11)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Cars' relation by index for model 'User' failed: %v", err)
	}
	models := make([]mapping.Model, len(cars))
	for i := range cars {
		models[i] = cars[i]
	}
	return u.builder.SetRelations(relation, models...)
}

// SetSons sets related model Sons and matches to given User.
func (u *usersQueryBuilder) SetSons(sons ...*User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(12)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Sons' relation by index for model 'User' failed: %v", err)
	}
	models := make([]mapping.Model, len(sons))
	for i := range sons {
		models[i] = sons[i]
	}
	return u.builder.SetRelations(relation, models...)
}

// SetSister sets related model Sister and matches to given User.
func (u *usersQueryBuilder) SetSister(sister *User) error {
	if u.err != nil {
		return u.err
	}
	relation, err := Users.Model.RelationByIndex(13)
	if err != nil {
		return errors.Newf(mapping.ClassInternal, "getting 'Sister' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.SetRelations(relation, sister)
}

// RemoveFavoriteCar removes related model FavoriteCar and matches to given User.
func (u *usersQueryBuilder) RemoveFavoriteCar() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := Users.Model.RelationByIndex(10)
	if err != nil {
		return 0, errors.Newf(mapping.ClassInternal, "getting 'FavoriteCar' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveCars removes related model Cars and matches to given User.
func (u *usersQueryBuilder) RemoveCars() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := Users.Model.RelationByIndex(11)
	if err != nil {
		return 0, errors.Newf(mapping.ClassInternal, "getting 'Cars' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveSons removes related model Sons and matches to given User.
func (u *usersQueryBuilder) RemoveSons() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := Users.Model.RelationByIndex(12)
	if err != nil {
		return 0, errors.Newf(mapping.ClassInternal, "getting 'Sons' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// RemoveSister removes related model Sister and matches to given User.
func (u *usersQueryBuilder) RemoveSister() (int64, error) {
	if u.err != nil {
		return 0, u.err
	}
	relation, err := Users.Model.RelationByIndex(13)
	if err != nil {
		return 0, errors.Newf(mapping.ClassInternal, "getting 'Sister' relation by index for model 'User' failed: %v", err)
	}
	return u.builder.RemoveRelations(relation)
}

// Cars is the collection used to query Car model.
var Cars *cars

type cars struct {
	Model *mapping.ModelStruct
}

func initializeCars() error {
	mStruct, err := controller.ModelStruct(&Car{})
	if err != nil {
		return err
	}
	Cars = &cars{Model: mStruct}
	return nil
}

// Query creates the query for the Car.
func (c *cars) Query(db query.DB, models ...*Car) *carsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.Query(c.Model, queryModels...)
	return &carsQueryBuilder{builder: builder}
}

// QueryCtx creates the query for the Car with provided 'ctx' context.
func (c *cars) QueryCtx(ctx context.Context, db query.DB, models ...*Car) *carsQueryBuilder {
	var queryModels []mapping.Model
	if len(models) > 0 {
		queryModels = make([]mapping.Model, len(models))
		for i, model := range models {
			queryModels[i] = model
		}
	}
	builder := db.QueryCtx(ctx, c.Model, queryModels...)
	return &carsQueryBuilder{builder: builder}
}

// carsQueryBuilder is the query builder used to create and execute
// queries for the Carmodel.
type carsQueryBuilder struct {
	builder query.Builder
	err     error
}

// Scope returns given query scope.
func (c *carsQueryBuilder) Scope() *query.Scope {
	return c.builder.Scope()
}

// Err returns errors that occurred during query building process.
func (c *carsQueryBuilder) Err() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Err()
}

// Ctx returns the context of given query builder.
func (c *carsQueryBuilder) Ctx() context.Context {
	return c.builder.Ctx()
}

// Count returns the number of model instances for provided query.
func (c *carsQueryBuilder) Count() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Count()
}

// Insert new 'Car' instance(s) into the store.
func (c *carsQueryBuilder) Insert() error {
	if c.err != nil {
		return c.err
	}
	return c.builder.Insert()
}

// Update updates given 'Car' instances.
func (c *carsQueryBuilder) Update() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Update()
}

// Find returns all Car models that matches to given query.
func (c *carsQueryBuilder) Find() ([]*Car, error) {
	if c.err != nil {
		return nil, c.err
	}
	queryModels, err := c.builder.Find()
	if err != nil {
		return nil, err
	}
	models := make([]*Car, len(queryModels))
	for i := range queryModels {
		models[i] = queryModels[i].(*Car)
	}
	return models, nil
}

// Get returns single Car model that matches given query.
// If the model is not found the function returns error of class.QueryValueNoResult.
func (c *carsQueryBuilder) Get() (*Car, error) {
	if c.err != nil {
		return nil, c.err
	}
	model, err := c.builder.Get()
	if err != nil {
		return nil, err
	}
	return model.(*Car), nil
}

// Delete deletes all Car values from the store that matches given query.
func (c *carsQueryBuilder) Delete() (int64, error) {
	if c.err != nil {
		return 0, c.err
	}
	return c.builder.Delete()
}

// Filter adds the 'filter' to the given query.
func (c *carsQueryBuilder) Filter(filter *query.FilterField) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Filter(filter)
	return c
}

// Where creates query with given 'filter' and 'values'.
func (c *carsQueryBuilder) Where(filter string, values ...interface{}) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Where(filter, values...)
	return c
}

// Limit sets the maximum number of objects returned by the Find process,
// Returns error if the given scope has already different type of pagination.
func (c *carsQueryBuilder) Limit(limit int64) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Limit(limit)
	return c
}

// Offset sets the query result's offset. It says to skip as many object's from the repository
// before beginning to return the result. 'Offset' 0 is the same as omitting the 'Offset' clause.
// Returns error if the given scope has already different type of pagination.
func (c *carsQueryBuilder) Offset(offset int64) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	c.builder.Offset(offset)
	return c
}

// Select adds the fields to the scope's fieldset.
// Allowed fields to select:
//  - ID / id
//  - Plates / plates
func (c *carsQueryBuilder) Select(fields ...string) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	var fieldSet []*mapping.StructField
	for _, field := range fields {
		structField, ok := Cars.Model.FieldByName(field)
		if !ok {
			c.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not valid for model: 'cars'", field)
			return c
		}
		fieldSet = append(fieldSet, structField)
	}
	c.builder.Select(fieldSet...)
	return c
}

// OrderBy adds the sort fields into query scope. By default field is ordered ascending. In order to sort descending
// add '-' before the field name i.e. '-id'. The order of the fields relates to the significance of the sorting order.
// Allowed fields to sort:
//  - ID
//  - Plates
func (c *carsQueryBuilder) OrderBy(fields ...string) *carsQueryBuilder {
	if c.err != nil {
		return c
	}
	var sortFields []*query.SortField
	for _, field := range fields {
		if len(field) == 0 {
			c.err = errors.New(mapping.ClassInvalidModelField, "cannot set sorting order for an empty field for model: 'cars'")
			return c
		}
		var order query.SortOrder
		if field[0] == '-' {
			order = query.DescendingOrder
			field = field[1:]
		}
		structField, ok := Cars.Model.FieldByName(field)
		if !ok {
			c.err = errors.Newf(mapping.ClassInvalidModelField, "field: '%s' is not valid for model: 'cars'", field)
			return c
		}
		sortFields = append(sortFields, &query.SortField{StructField: structField, Order: order})
	}
	c.builder.OrderBy(sortFields...)
	return c
}
