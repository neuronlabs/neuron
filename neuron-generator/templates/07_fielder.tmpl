{{define "fielder" -}}
{{- $out := . -}}
// Compile time check if {{.Name}} implements mapping.Fielder interface.
var _ mapping.Fielder = &{{.Name}}{}

// GetFieldZeroValue implements mapping.Fielder interface.s
func ({{.Receiver}} *{{.Name}}) GetFieldZeroValue(field *mapping.StructField) (interface{}, error) {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        return {{if eq $field.Zero "nil"}}{{if $field.IsPointer}}({{end}}{{$field.Type}}{{if $field.IsPointer}}){{end}}({{end}}{{$field.Zero}}{{if eq $field.Zero "nil"}}){{end}}, nil
    {{end -}}
    default:
        return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
    }
}

// IsFieldZero implements mapping.Fielder interface.
func ({{.Receiver}} *{{.Name}}) IsFieldZero(field *mapping.StructField) (bool, error) {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        return {{$field.IsZero}}, nil
    {{end -}}}
    return false, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
}

// SetFieldZeroValue implements mapping.Fielder interface.s
func ({{.Receiver}} *{{.Name}}) SetFieldZeroValue(field *mapping.StructField) error {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        {{$out.Receiver}}.{{$field.Name}} = {{$field.Zero}}
    {{end -}}
    default:
        return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field name: '%s'", field.Name())
    }
    return nil
}

// GetHashableFieldValue implements mapping.Fielder interface.
func ({{.Receiver}} *{{.Name}}) GetHashableFieldValue(field *mapping.StructField) (interface{}, error) {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        {{if $field.IsPointer -}}
        if {{$out.Receiver}}.{{$field.Name}} == nil {
            return {{$out.Receiver}}.{{$field.Name}}, nil
        }
        {{end -}}
        {{if $field.IsByteSlice -}}
            return string({{if $field.IsPointer}}*{{end}}{{$out.Receiver}}.{{$field.Name}}), nil
        {{- else -}}
            return {{if $field.IsPointer}}*{{end}}{{$out.Receiver}}.{{$field.Name}}, nil
        {{- end}}
    {{end -}}}
    return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: '{{.Name}}'", field.Name())
}

// GetFieldValue implements mapping.Fielder interface.
func ({{.Receiver}} *{{.Name}}) GetFieldValue(field *mapping.StructField) (interface{}, error) {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        return {{$out.Receiver}}.{{$field.Name}}, nil
    {{end -}}}
    return nil, errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for given model: {{.Name}}'", field.Name())
}

// SetFieldValue implements mapping.Fielder interface.
func ({{.Receiver}} *{{.Name}}) SetFieldValue(field *mapping.StructField, value interface{}) (err error) {
    switch field.Index[0] {
    {{range $field := .Fields -}}
    case {{$field.Index}}: // {{$field.Name}}
        {{if $field.IsPointer -}}
        if value == nil {
            {{$out.Receiver}}.{{$field.Name}} = nil
            return nil
        }
        {{end -}}
        if v, ok := value.({{$field.Type}}); ok {
            {{$out.Receiver}}.{{$field.Name}} = v
            return nil
        }{{if and (not $field.IsSlice) $field.IsPointer }}
        // Check if it is non-pointer value.
        if v, ok := value.({{$field.BaseType}}); ok {
            {{$out.Receiver}}.{{$field.Name}} = &v
            return nil
        }{{end}}
        {{if $field.WrappedTypes -}}
        // Checked wrapped types.
        {{range $wrapped := $field.WrappedTypes -}}
        if v, ok := value.({{$wrapped}}); ok {
            {{if $field.IsPointer -}}
            temp := {{slice $field.Type 1}}(v)
            {{$out.Receiver}}.{{$field.Name}} = &temp
            {{else -}}
            {{$out.Receiver}}.{{$field.Name}} = {{$field.BaseType}}(v)
            {{end -}}
            return nil
        }{{end}}
        {{end -}}
        {{if not (eq (len $field.AlternateTypes) 0) -}}
        {{if eq (len $field.AlternateTypes) 1 -}}
        // Check alternate types for the {{$field.Name}}.
        if v, ok := value.({{index $field.AlternateTypes 0}}); ok {
            {{if $field.IsPointer -}}
            temp := {{slice $field.Type 1}}(v)
            {{$out.Receiver}}.{{$field.Name}} = &temp
            {{- else -}}
            {{$out.Receiver}}.{{$field.Name}} = {{$field.Type}}(v)
            {{- end}}
            return nil
        }
        return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
        {{- else -}}
        switch v := value.(type) {
        {{range $alternateType := $field.AlternateTypes -}}
        case {{$alternateType}}:
            {{if $field.IsPointer -}}
            temp := {{$field.BaseType}}(v)
            {{$out.Receiver}}.{{$field.Name}} = &temp
            {{- else -}}
            {{$out.Receiver}}.{{$field.Name}} = {{$field.Type}}(v)
            {{- end}}{{if $field.IsPointer }}
        case *{{$alternateType}}:
            temp := {{$field.BaseType}}(*v)
            {{$out.Receiver}}.{{$field.Name}} = &temp
        {{- end}}
        {{end -}}default:
            return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
        }
        return nil
        {{- end}}
        {{- /* TODO: set the scanner as switch type case*/ -}}
        {{ else -}}
            return errors.Newf(mapping.ClassInvalidFieldValue, "provided invalid field type: '%T' for the field: %s", value, field.Name())
        {{- end}}
    {{end -}}
    default:
        return errors.Newf(mapping.ClassInvalidModelField, "provided invalid field: '%s' for the model: '{{$out.Name}}'", field.Name())
    }
}
{{- end}}